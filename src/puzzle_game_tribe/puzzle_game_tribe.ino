#include <Arduboy2.h>

Arduboy2 arduboy;

const int SCREEN_WIDTH = 128;
const int SCREEN_HEIGHT = 64;


enum GameState {
  START_SCREEN,
  CHARACTER_SELECT,
  GAMEPLAY
};

GameState currentState = START_SCREEN;


bool startMusicPlaying = false;
unsigned long musicStartTime = 0;
int currentNote = 0;


const int melodyNotes[] = {523, 659, 784, 659, 784, 880, 784, 659, 523, 659, 784, 880, 1047, 880, 784, 659}; 
const int melodyDurations[] = {200, 200, 200, 200, 200, 400, 200, 200, 200, 200, 200, 200, 400, 200, 200, 400}; 


const int PLAYER_SIZE = 8;
const int PLAYER_X = 20; 
int playerY = 32;
int currentPlayerPosition = 1; 
int playerSpeed = 0; 
int previousPlayerPosition = 1; 


enum ShapeType {
  CIRCLE,
  SQUARE,
  TRIANGLE,
  RHOMBUS,
  SHAPE_COUNT
};


struct ShapeBlock {
  int x;
  int shapes[4];
  int gapPosition;
  int width = 25;
  bool passed = false;
  bool shapeHighlighted[4] = {false, false, false, false}; 
  bool soundPlayed[4] = {false, false, false, false}; 
};

const int MAX_BLOCKS = 3;
ShapeBlock blocks[MAX_BLOCKS];
int blockSpeed = 1; 


int points = 0; 
bool gameRunning = true;
bool gameOverSoundPlayed = false; 


const int SHAPE_SIZE = 8;
const int SHAPE_SPACING = 4; 
const int BLOCKS_START_Y = 12; 

// Позиции центров для выравнивания игрока
int shapeCenters[4] = {0, 0, 0, 0};
bool centersCalculated = false;

// Переменные для обработки управления
bool upPressed = false;
bool downPressed = false;

const uint8_t PROGMEM logoImg[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0x00, 0x80, 0xc0, 0xc0, 0xc0, 0xc0, 0x80, 0x00, 0x00, 0xc0, 0xf0, 0xfc, 0xf0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x0f, 0x8c, 0x4c, 0x40, 0x37, 0x37, 0x37, 0x37, 0x37, 0x47, 0x47, 0x87, 0x07, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xfa, 0xfb, 0x0b, 0x0b, 0x0b, 0x0b, 0x0a, 0x30, 0x30, 0x40, 0x80, 0x00, 0xff, 0xff, 0xff, 0xff, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x07, 0xf3, 0xf3, 0x08, 0x0c, 0x46, 0x46, 0xb3, 0x93, 0x93, 0x23, 0x24, 0x24, 0x18, 0x00, 0x40, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0x40, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x80, 0xf6, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x89, 0x07, 0x07, 0x01, 0x70, 0x70, 0x8f, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xe7, 0x67, 0x61, 0x61, 0x60, 0x81, 0x81, 0x0e, 0x11, 0xef, 0x1f, 0xff, 0xff, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x08, 0xe1, 0xe1, 0x61, 0x66, 0xe6, 0xe6, 0x88, 0x08, 0x08, 0x09, 0x91, 0x91, 0xe1, 0x06, 0x06, 0xf8, 0x01, 0x83, 0xc7, 0xef, 0xf7, 0xfb, 0xfd, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0xf8, 0xfc, 0xfc, 0xfe, 0xfe, 0xfe, 0xfc, 0xfc, 0xf8, 0xf0, 0xc0, 0x07, 0x10, 0x10, 0x10, 0x1f, 0x01, 0x01, 0x06, 0x08, 0x08, 0x11, 0x17, 0x1c, 0x03, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x0f, 0x0f, 0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x18, 0x06, 0x09, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x08, 0x09, 0x01, 0x06, 0x08, 0x08, 0x09, 0x01, 0x09, 0x01, 0x09, 0x09, 0x08, 0x06, 0x06, 0x01, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0f, 0x1f, 0x1f, 0x3f, 0x3f, 0x3f, 0x1f, 0x1f, 0x0f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

// Выбор персонажа
int selectedCharacter = 0;
ShapeType playerShape = TRIANGLE;

// Спрайты персонажей
const uint8_t PROGMEM capybaraImg[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0xc0, 0x40, 0xe0, 0xa0, 0x50, 0xa8, 0x50, 0xa8, 0x50, 0xa8, 0x50, 0x40, 0xa0, 0x40, 0x80, 0x40, 0x80, 0x00, 0x80, 0xe0, 0xe0, 0xf0, 0xf0, 0xf8, 0xf8, 0xf8, 0xfc, 0xfc, 0xf8, 0xfc, 0xfc, 0xf4, 0xfc, 0xf4, 0xec, 0xac, 0x54, 0xac, 0x54, 0xa8, 0x54, 0xa8, 0x5c, 0x58, 0xa8, 0x50, 0xa0, 0x60, 0xe0, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x50, 0xa8, 0x50, 0xac, 0xad, 0x53, 0xad, 0x52, 0xad, 0x52, 0xad, 0x52, 0x56, 0xaa, 0x50, 0xa9, 0x52, 0xad, 0x52, 0xad, 0xad, 0x52, 0xad, 0xf2, 0xfd, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfd, 0xfa, 0xed, 0x52, 0xad, 0xad, 0x52, 0xad, 0x52, 0xad, 0x52, 0xad, 0x52, 0x52, 0xa8, 0x50, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x05, 0x02, 0x05, 0x02, 0x02, 0x0d, 0x02, 0x0d, 0x02, 0x0d, 0x02, 0x05, 0x0d, 0x02, 0x0d, 0x12, 0xad, 0x52, 0xad, 0x52, 0x52, 0xad, 0x52, 0xaf, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0xad, 0x52, 0x52, 0xad, 0x52, 0xad, 0x52, 0xad, 0x52, 0xad, 0xad, 0x52, 0xad, 0x72, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0xf9, 0xa9, 0x56, 0xa9, 0x56, 0x29, 0x16, 0x29, 0x57, 0x57, 0xaf, 0x5f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x1f, 0x1f, 0x1f, 0x57, 0xab, 0x57, 0xa9, 0x56, 0xa9, 0x56, 0xa9, 0x01, 0x06, 0x01, 0x06, 0x01, 0x06, 0x09, 0x06, 0x16, 0x29, 0x16, 0x29, 0x16, 0x29, 0x16, 0x28, 0xa8, 0x54, 0xa8, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0xc0, 0xf0, 0xb8, 0xd6, 0xf6, 0x29, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xa9, 0xf6, 0xfc, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xa8, 0x56, 0xa9, 0x56, 0x29, 0x16, 0x09, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfd, 0xf8, 0xf8, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x01, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x06, 0x07, 0x07, 0x07, 0x06, 0x07, 0x06, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x07, 0x07, 0x07, 0x07, 0x00, 
};

const uint8_t PROGMEM alpacaImg[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0xf8, 0xfc, 0x14, 0xf7, 0xac, 0x5e, 0xbf, 0xf0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xe0, 0xc0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x0f, 0x1f, 0x1a, 0xca, 0xb5, 0x4a, 0xb5, 0x4a, 0x78, 0xfe, 0x03, 0xfa, 0xf8, 0xfa, 0xfb, 0xfa, 0xfb, 0xf8, 0xfa, 0xf8, 0xfa, 0xfa, 0xf8, 0xfa, 0xf8, 0xfa, 0xf8, 0x02, 0xfe, 0x4b, 0xa5, 0x42, 0xb5, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf7, 0x2a, 0xd1, 0xd5, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xd5, 0x2a, 0xd5, 0x2a, 0x2a, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0f, 0x0f, 0xff, 0xfa, 0xba, 0xaf, 0x58, 0xa7, 0x57, 0x57, 0xb7, 0x57, 0xb7, 0x57, 0xa7, 0x17, 0x27, 0x17, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x1f, 0xaa, 0x55, 0xaa, 0x55, 0x15, 0x2a, 0x15, 0xa8, 0x54, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x1f, 0x5f, 0x57, 0x04, 0x03, 0x00, 0x03, 0xa3, 0x54, 0xab, 0x54, 0xab, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x2b, 0x14, 0x0b, 0x00, 0x00, 0x00, 0x04, 0xab, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x05, 0x28, 0x00, 0x00, 0x00, 0x02, 0x05, 0x02, 0x01, 0x02, 0x0d, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

const uint8_t PROGMEM honeyBadgerImg[] = {
  0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x08, 0x02, 0x00, 0x2a, 0x95, 0x6a, 0x95, 0x95, 0x6a, 0x95, 0x6a, 0x04, 0x04, 0x08, 0x10, 0x60, 0x90, 0x60, 0x60, 0x80, 0x60, 0x90, 0x60, 0x60, 0x90, 0x60, 0xd0, 0xe8, 0xd0, 0x90, 0x68, 0x94, 0x68, 0x94, 0x94, 0x6a, 0x94, 0x6a, 0x94, 0x68, 0x68, 0x94, 0x68, 0x90, 0x60, 0x60, 0x80, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x2d, 0x50, 0x80, 0x04, 0x0c, 0x0c, 0x00, 0x01, 0x82, 0x82, 0x85, 0x82, 0x01, 0x04, 0x06, 0x82, 0x40, 0x2d, 0x02, 0x05, 0x05, 0x12, 0x0d, 0x12, 0xad, 0xfd, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfd, 0xf2, 0xad, 0x52, 0x52, 0xad, 0x52, 0xad, 0x52, 0xad, 0xad, 0x52, 0xad, 0x52, 0xad, 0x2d, 0x02, 0x05, 0x00, 0x01, 0x02, 0x00, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x14, 0x00, 0x00, 0x04, 0x08, 0x10, 0x21, 0x23, 0x01, 0x01, 0x10, 0x0a, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xd4, 0xcb, 0x14, 0x2b, 0x14, 0x14, 0x0b, 0x04, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x60, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa1, 0x1a, 0x04, 0x38, 0x38, 0x7e, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x7f, 0x3f, 0x3f, 0xbf, 0xbf, 0x7f, 0x3f, 0x7f, 0x3c, 0x30, 0x18, 0x04, 0x08, 0x04, 0x02, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x10, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x61, 0x1a, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0xd4, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x14, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x09, 0x00, 0x09, 0x00, 0x04, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0x1a, 0x00, 0x10, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x25, 0x00, 0x20, 0x20, 0x18, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

const uint8_t PROGMEM salamanderImg[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0xa0, 0x20, 0x10, 0x28, 0x10, 0x08, 0x08, 0x10, 0x28, 0x10, 0x28, 0x10, 0x10, 0x20, 0x50, 0x20, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x90, 0x68, 0x94, 0x6b, 0x1c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf1, 0xf8, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x05, 0x7a, 0xa5, 0x5a, 0xa0, 0x50, 0xc0, 0xe0, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0xae, 0x5f, 0xbf, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x1e, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xe0, 0x50, 0xa0, 0x18, 0x80, 0xa4, 0x58, 0xa4, 0x58, 0xa0, 0x40, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x09, 0x07, 0x09, 0x17, 0x29, 0xa8, 0x54, 0xb8, 0x54, 0xa8, 0x56, 0x56, 0xa9, 0x56, 0xe9, 0x56, 0xa8, 0xaa, 0x57, 0xab, 0xd7, 0xef, 0xdf, 0x3f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xbf, 0xdf, 0x6f, 0xb7, 0x5b, 0x55, 0xa8, 0x56, 0xa9, 0x54, 0xa8, 0xf8, 0x7c, 0xb8, 0x56, 0xa9, 0xa9, 0x56, 0xa9, 0x56, 0xa9, 0x56, 0x14, 0x2c, 0x1e, 0x0d, 0x06, 0x01, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x35, 0x4a, 0xb5, 0x4a, 0xb5, 0xb5, 0x4a, 0x35, 0x4b, 0x15, 0x0b, 0x0a, 0x15, 0x0a, 0x15, 0x0b, 0x0f, 0x1f, 0x0f, 0x17, 0x0b, 0x16, 0x15, 0x0e, 0x17, 0x0a, 0x15, 0x4a, 0x4b, 0xb5, 0x4a, 0x95, 0x4a, 0x85, 0x01, 0x02, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x02, 0x02, 0x0d, 0x02, 0x05, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

const uint8_t* const characterSprites[] PROGMEM = {
  capybaraImg,
  alpacaImg,
  honeyBadgerImg,
  salamanderImg
};


const uint8_t characterShapes[] PROGMEM = {
  CIRCLE,    
  SQUARE,     
  TRIANGLE,  
  RHOMBUS     
};


int centerTextX(const char* text) {
  return (128 - (strlen(text) * 6)) / 2;
}

void drawLeftArrow(int x, int y) {
  arduboy.drawPixel(x + 0, y + 2, WHITE);
  arduboy.drawPixel(x + 1, y + 1, WHITE);
  arduboy.drawPixel(x + 1, y + 3, WHITE);
  arduboy.drawPixel(x + 2, y + 0, WHITE);
  arduboy.drawPixel(x + 2, y + 4, WHITE);
}

void drawRightArrow(int x, int y) {
  arduboy.drawPixel(x + 4, y + 2, WHITE);
  arduboy.drawPixel(x + 3, y + 1, WHITE);
  arduboy.drawPixel(x + 3, y + 3, WHITE);
  arduboy.drawPixel(x + 2, y + 0, WHITE);
  arduboy.drawPixel(x + 2, y + 4, WHITE);
}


void shuffleArray(int array[], int size) {
  for (int i = size - 1; i > 0; i--) {
    int j = random(0, i + 1);
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
}

void playSuccessSound() {

  tone(PIN_SPEAKER_1, 523, 80); 
}

void playCollisionSound() {

  tone(PIN_SPEAKER_1, 220, 200); 
}

void playGameOverSound() {
  
  tone(PIN_SPEAKER_1, 392, 150); 
  delay(160);
  tone(PIN_SPEAKER_1, 349, 150); 
  delay(160);
  tone(PIN_SPEAKER_1, 330, 150); 
  delay(160);
  tone(PIN_SPEAKER_1, 294, 300); 
}

void playSelectSound() {
  
  tone(PIN_SPEAKER_1, 659, 100); 
}

void playSwitchSound() {
  
  tone(PIN_SPEAKER_1, 523, 60); 
}


void updateStartMusic() {
  if (!startMusicPlaying) {
    startMusicPlaying = true;
    musicStartTime = millis();
    currentNote = 0;
    tone(PIN_SPEAKER_1, melodyNotes[currentNote], melodyDurations[currentNote]);
  } else {
    unsigned long currentTime = millis();
    unsigned long noteStartTime = musicStartTime;
    
    
    for (int i = 0; i < currentNote; i++) {
      noteStartTime += melodyDurations[i];
    }
    
   
    if (currentTime - noteStartTime >= melodyDurations[currentNote]) {
      currentNote++;
      if (currentNote < 16) { 
        tone(PIN_SPEAKER_1, melodyNotes[currentNote], melodyDurations[currentNote]);
      } else {
        
        currentNote = 0;
        musicStartTime = millis();
        tone(PIN_SPEAKER_1, melodyNotes[currentNote], melodyDurations[currentNote]);
      }
    }
  }
}


void stopStartMusic() {
  startMusicPlaying = false;
  noTone(PIN_SPEAKER_1);
}



void calculateShapeCenters() {
  int availableHeight = SCREEN_HEIGHT - BLOCKS_START_Y;
  int totalShapesHeight = 4 * SHAPE_SIZE + 3 * SHAPE_SPACING;
  int startY = BLOCKS_START_Y + (availableHeight - totalShapesHeight) / 2;
  
  for (int j = 0; j < 4; j++) {
    shapeCenters[j] = startY + j * (SHAPE_SIZE + SHAPE_SPACING) + SHAPE_SIZE / 2;
  }
  centersCalculated = true;
}

void updatePlayer() {
  if (!centersCalculated) {
    calculateShapeCenters();
  }  
  
  previousPlayerPosition = currentPlayerPosition;
  
  
  playerY = shapeCenters[currentPlayerPosition] - SHAPE_SIZE / 2;
  
  
  if (arduboy.pressed(UP_BUTTON)) {
    if (!upPressed) {
      upPressed = true;
      if (currentPlayerPosition > 0) {
        currentPlayerPosition--;
      }
    }
  } else {
    upPressed = false;
  }
  
  if (arduboy.pressed(DOWN_BUTTON)) {
    if (!downPressed) {
      downPressed = true;
      if (currentPlayerPosition < 3) {
        currentPlayerPosition++;
      }
    }
  } else {
    downPressed = false;
  }
  
  
  playerSpeed = abs(currentPlayerPosition - previousPlayerPosition);
}



void resetBlock(int index) {
  blocks[index].x = SCREEN_WIDTH;
  blocks[index].gapPosition = random(0, 4); 
  
  
  int allShapes[4] = {CIRCLE, SQUARE, TRIANGLE, RHOMBUS};
  
  
  shuffleArray(allShapes, 4);
  
  
  for (int i = 0; i < 4; i++) {
    blocks[index].shapes[i] = allShapes[i];
    blocks[index].shapeHighlighted[i] = false;
    blocks[index].soundPlayed[i] = false;
  }
  

  blocks[index].shapes[blocks[index].gapPosition] = playerShape;
  blocks[index].passed = false;
}

void updateBlocks() {
  for (int i = 0; i < MAX_BLOCKS; i++) {

    blocks[i].x -= blockSpeed;
    
   
    if (!blocks[i].passed) {
      
      int shapeAtPlayerPosition = blocks[i].shapes[currentPlayerPosition];
      
      
      if (shapeAtPlayerPosition == playerShape) {
       
        int blockCenterX = blocks[i].x + blocks[i].width / 2;
        int playerCenterX = PLAYER_X + PLAYER_SIZE / 2;
        
        
        if (abs(blockCenterX - playerCenterX) <= 2) {
          blocks[i].shapeHighlighted[currentPlayerPosition] = true;
          
         
          if (!blocks[i].soundPlayed[currentPlayerPosition]) {
            blocks[i].soundPlayed[currentPlayerPosition] = true;
            playSuccessSound();
          }
        }
      }
    }
    
    
    if (!blocks[i].passed && blocks[i].x + blocks[i].width < PLAYER_X) {
      blocks[i].passed = true;
      points++; 
      
      
      blockSpeed = 1 + points / 5;
    }
    
   
    if (blocks[i].x < -blocks[i].width) {
      resetBlock(i);
      
      int farthestX = 0;
      for (int j = 0; j < MAX_BLOCKS; j++) {
        if (blocks[j].x > farthestX) farthestX = blocks[j].x;
      }
      blocks[i].x = farthestX + 100; 
    }
    
   
    if (checkCollision(i)) {
      gameRunning = false;
      playCollisionSound();
    }
  }
  playerSpeed = blockSpeed;
}

bool checkCollision(int blockIndex) {
  ShapeBlock block = blocks[blockIndex];
  
 
  if (PLAYER_X + PLAYER_SIZE > block.x && PLAYER_X < block.x + block.width) {
    
    int shapeAtPlayerPosition = block.shapes[currentPlayerPosition];
    
    
    if (shapeAtPlayerPosition != playerShape) {
      return true;
    }
  }
  return false;
}




void drawTriangle(int x, int y, int size, bool filled = false) {
  if (filled) {
   
    for (int i = 0; i < size; i++) {
      int startX = x + (size - i) / 2;
      int endX = x + size - (size - i) / 2;
      arduboy.drawLine(startX, y + i, endX, y + i);
    }
  } else {
    arduboy.drawLine(x, y + size, x + size, y + size); 
    arduboy.drawLine(x, y + size, x + size/2, y);      
    arduboy.drawLine(x + size/2, y, x + size, y + size); 
  }
}


void drawCircle(int x, int y, int size, bool filled = false) {
  if (filled) {
    arduboy.fillCircle(x + size/2, y + size/2, size/2);
  } else {
    arduboy.drawCircle(x + size/2, y + size/2, size/2);
  }
}


void drawSquare(int x, int y, int size, bool filled = false) {
  if (filled) {
    arduboy.fillRect(x, y, size, size);
  } else {
    arduboy.drawRect(x, y, size, size);
  }
}


void drawRhombus(int x, int y, int size, bool filled = false) {
  int centerX = x + size/2;
  int centerY = y + size/2;
  int halfSize = size/2;

  if (filled) {
    
    for (int row = 0; row < size; row++) {
    int width;
      if (row < halfSize) {
        width = row;  
      } else {
        width = size - row - 1;  
      }
      arduboy.drawLine(centerX - width, y + row, centerX + width, y + row);
    }
  } else {
    arduboy.drawLine(centerX, y, x + size, centerY);     
    arduboy.drawLine(x + size, centerY, centerX, y + size); 
    arduboy.drawLine(centerX, y + size, x, centerY);     
    arduboy.drawLine(x, centerY, centerX, y);          
  }
}

void drawShape(int shapeType, int x, int y, int size, bool highlighted = false) {
  switch (shapeType) {
    case CIRCLE:
      drawCircle(x, y, size, highlighted);
      break;
    case SQUARE:
      drawSquare(x, y, size, highlighted);
      break;
    case TRIANGLE:
      drawTriangle(x, y, size, highlighted);
      break;
    case RHOMBUS:
      drawRhombus(x, y, size, highlighted);
      break;
  }
}

void drawGameOverScreen() {

  const int boxWidth = 100;
  const int boxHeight = 40;
  const int boxX = (SCREEN_WIDTH - boxWidth) / 2;
  const int boxY = (SCREEN_HEIGHT - boxHeight) / 2;
  
  
  arduboy.fillRect(boxX, boxY, boxWidth, boxHeight, BLACK);
  

  arduboy.drawRect(boxX, boxY, boxWidth, boxHeight, WHITE);
  
 
  const int textWidthFinish = 6 * 6; 
  const int textWidthPoints = 6 * 6;
  const int textWidthRestart = 6 * 12;
  

  int textXFinish = boxX + (boxWidth - textWidthFinish) / 2;
  arduboy.setCursor(textXFinish, boxY + 5);
  arduboy.print("FINISH");

  arduboy.setCursor(boxX + 20, boxY + 17);
  arduboy.print("Points: ");
  arduboy.print(points);
  

  int textXRestart = boxX + (boxWidth - textWidthRestart) / 2;
  arduboy.setCursor(textXRestart, boxY + 27);
  arduboy.print("A to restart");
}

void drawStartScreen() {
  arduboy.clear();
  
  
  const int LOGO_WIDTH = 96;
  const int LOGO_HEIGHT = 40;
  const int LOGO_X = (SCREEN_WIDTH - LOGO_WIDTH) / 2;
  const int LOGO_Y = 5;
  
  arduboy.drawBitmap(LOGO_X, LOGO_Y, logoImg, LOGO_WIDTH, LOGO_HEIGHT, WHITE);
  
  const char* instruction = "Press A to start";
  int instructionX = centerTextX(instruction);
  arduboy.setCursor(instructionX, 50);
  arduboy.print(instruction);
  
 
  updateStartMusic();
  
  arduboy.display();
}

void drawCharacterSelect() {
  arduboy.clear();

  const char* title = "CHOOSE YOUR TRIBE";
  int titleX = centerTextX(title);
  arduboy.setCursor(titleX, 2);
  arduboy.print(title);

  const int SPRITE_W = 72;
  const int SPRITE_H = 46;
  const int CENTER_X = 64 - SPRITE_W / 2;
  const int CENTER_Y = 32 - SPRITE_H / 2;
  const int MARGIN = 10;

  static unsigned long lastBlinkTime = 0;
  static bool showArrows = true;
  static int previousCharacter = selectedCharacter;

  if (millis() - lastBlinkTime > 800) {
    showArrows = !showArrows;
    lastBlinkTime = millis();
  }

  int arrowY = CENTER_Y + SPRITE_H / 2 + 5;
  if (showArrows) {
    drawLeftArrow(MARGIN, arrowY);
    drawRightArrow(128 - MARGIN - 8, arrowY);
  }

  const uint8_t* sprite = (const uint8_t*)pgm_read_ptr(&characterSprites[selectedCharacter]);
  arduboy.drawBitmap(CENTER_X, CENTER_Y, sprite, SPRITE_W, SPRITE_H, WHITE);
  
    
  if (selectedCharacter != previousCharacter) {
    playSwitchSound();
    previousCharacter = selectedCharacter;
  }

  const char* instruction2 = "Press B to select";
  int instruction2X = centerTextX(instruction2);
  arduboy.setCursor(instruction2X, 55);
  arduboy.print(instruction2);

  arduboy.display();
}

void drawGameplay() {
  arduboy.clear();
  

  drawShape(playerShape, PLAYER_X, playerY, SHAPE_SIZE);
  

  for (int i = 0; i < MAX_BLOCKS; i++) {
    int availableHeight = SCREEN_HEIGHT - BLOCKS_START_Y;
    int totalShapesHeight = 4 * SHAPE_SIZE + 3 * SHAPE_SPACING;
    int startY = BLOCKS_START_Y + (availableHeight - totalShapesHeight) / 2;
    
   
    int shapeX = blocks[i].x + (blocks[i].width - SHAPE_SIZE) / 2;
    
    for (int j = 0; j < 4; j++) {
      int shapeY = startY + j * (SHAPE_SIZE + SHAPE_SPACING);
    
      drawShape(blocks[i].shapes[j], shapeX, shapeY, SHAPE_SIZE, blocks[i].shapeHighlighted[j]);
    }
  }
  

  arduboy.setCursor(0, 0);
  arduboy.print("Points: ");
  arduboy.print(points);
  

  arduboy.setCursor(80, 0);
  arduboy.print("Speed: ");
  arduboy.print(playerSpeed);
  
  
  if (!gameRunning) {
    
    if (!gameOverSoundPlayed) {
      gameOverSoundPlayed = true;
      playGameOverSound();
    }
    drawGameOverScreen();
  }
  
  arduboy.display();
}



void restartGame() {
 
  playerShape = (ShapeType)pgm_read_byte(&characterShapes[selectedCharacter]);

  gameRunning = true;
  gameOverSoundPlayed = false; 
  points = 0; 
  blockSpeed = 1; 
  currentPlayerPosition = 1; 
  previousPlayerPosition = 1; 
  playerSpeed = 0; 
  centersCalculated = false; 
  calculateShapeCenters(); 
  playerY = shapeCenters[currentPlayerPosition] - SHAPE_SIZE / 2;
  
  for (int i = 0; i < MAX_BLOCKS; i++) {
    resetBlock(i);
    blocks[i].x = SCREEN_WIDTH + (i * 100); 
  }
}

void updateGameplay() {
  updatePlayer();
  updateBlocks();
}



void setup() {
  arduboy.begin();
  arduboy.setFrameRate(60);
  

  playerShape = TRIANGLE;
  for (int i = 0; i < MAX_BLOCKS; i++) {
    resetBlock(i);
    blocks[i].x = SCREEN_WIDTH + (i * 100); 
  }
  
  calculateShapeCenters();
}

void loop() {
  if (!arduboy.nextFrame()) return;
  
  arduboy.pollButtons();
  
  switch (currentState) {
    case START_SCREEN:
      drawStartScreen();
      if (arduboy.justPressed(A_BUTTON)) {
        stopStartMusic(); 
        currentState = CHARACTER_SELECT;
      }
      break;

    case CHARACTER_SELECT:
      drawCharacterSelect();
      if (arduboy.justPressed(LEFT_BUTTON)) {
        selectedCharacter = (selectedCharacter + 3) % 4;
      }
      if (arduboy.justPressed(RIGHT_BUTTON)) {
        selectedCharacter = (selectedCharacter + 1) % 4;
      }
      if (arduboy.justPressed(B_BUTTON)) {
        playSelectSound();
        delay(150); 
        restartGame();
        currentState = GAMEPLAY;
      }
      break;

    case GAMEPLAY:
      if (gameRunning) {
        updateGameplay();
      } else {
        if (arduboy.justPressed(A_BUTTON)) {
          currentState = CHARACTER_SELECT;
        }
        if (arduboy.justPressed(B_BUTTON)) {
          currentState = START_SCREEN;
        }
      }
      drawGameplay();
      break;
  }
}